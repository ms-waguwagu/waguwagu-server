pipeline {
  agent any

  // 수동 테스트용 강제 빌드 파라미터
  parameters {
    booleanParam(
      name: 'FORCE_BUILD',
      defaultValue: false,
      description: 'true면 matching-server 변경이 없어도 강제로 Build & Push 실행'
    )
  }

  environment {
    AWS_REGION   = "ap-northeast-2"
    ECR_REPO_URI = "269397878198.dkr.ecr.ap-northeast-2.amazonaws.com/t3-wagu-matching-server"

    // (CD 단계에서만 사용, 지금은 주석)
    CLUSTER_NAME = "T3-Wagu-Matching-EKS"
    NAMESPACE    = "matching"
    DEPLOYMENT_NAME = "matching-deploy"
    CONTAINER_NAME  = "matching"
  }

 
  options {
    skipDefaultCheckout(true)
  }

  // ✅5분마다 polling은 timestamps랑 무관.

  stages {
    stage("Checkout") {
      steps {
        checkout scm
      }
    }

    stage("Change check") {
      steps {
        script {
          //  "변경 없으면 빌드 막기"가 아니라,
          // - "변경 여부를 로그로만 남기고" 무조건 계속 진행한다.
          // (즉, git 변경이 없어도 ECR Push는 항상 됨)

          // FORCE_BUILD=true면 변경 체크를 무시하고 계속 진행
          if (params.FORCE_BUILD) {
            echo "FORCE_BUILD=true -> skip change check"
            return
          }

          // 첫 빌드(HEAD~1 없음) 방어: returnStatus 사용 ( echo 필요 없음)
          def hasPrev = sh(
            returnStatus: true,
            script: "git rev-parse HEAD~1 >/dev/null 2>&1"
          )

          if (hasPrev != 0) {
            echo "No previous commit (first build). Continue without change check."
            return
          }

          // 변경 여부 체크: grep 결과가 있으면 0, 없으면 1
          def changedRc = sh(
            returnStatus: true,
            script: "git diff --name-only HEAD~1..HEAD | grep -E '^matching-server/'"
          )

          // 변경이 없어도 error()로 막지 말고, 로그만 찍고 계속 진행
          if (changedRc != 0) {
            echo "No changes in matching-server/, but continue (always Build & Push)."
            // currentBuild.result = 'NOT_BUILT'  // 더 이상 NOT_BUILT로 바꾸지 않음
            // error("No changes in matching-server/. Skip.") // 더 이상 중단하지 않음
          } else {
            echo "Changes detected in matching-server/ -> proceed."
          }
        }
      }
    }

    stage("ECR Login") {
      steps {
        sh '''
          set -e
          aws ecr get-login-password --region ${AWS_REGION} \
            | docker login --username AWS --password-stdin ${ECR_REPO_URI%/*}
        '''
      }
    }

    stage("Build & Push") {
      steps {
        script {
          // 태그 전략: 커밋해시(7) + 빌드번호
          def tag = "${env.GIT_COMMIT.take(7)}-${env.BUILD_NUMBER}"
          env.IMAGE_TAG = tag
          env.IMAGE_URI = "${env.ECR_REPO_URI}:${tag}"
          echo "IMAGE_URI = ${env.IMAGE_URI}"
        }

        sh '''
          set -e
          cd matching-server
          docker build -t ${ECR_REPO_URI}:${IMAGE_TAG} .
          docker push ${ECR_REPO_URI}:${IMAGE_TAG}
        '''
      }
    }

    /*
    // ===========================
    // CD 단계 (클러스터 생기면 주석 해제)
    // ===========================

    stage("Configure kubeconfig") {
      steps {
        sh '''
          set -e
          aws eks update-kubeconfig --region ${AWS_REGION} --name ${CLUSTER_NAME}
          kubectl get ns ${NAMESPACE}
        '''
      }
    }

    stage("Deploy (Update Deployment image)") {
      steps {
        sh '''
          set -e
          kubectl -n ${NAMESPACE} set image deploy/${DEPLOYMENT_NAME} ${CONTAINER_NAME}=${IMAGE_URI}
          kubectl -n ${NAMESPACE} rollout status deploy/${DEPLOYMENT_NAME} --timeout=300s
          kubectl -n ${NAMESPACE} get deploy ${DEPLOYMENT_NAME} -o wide
        '''
      }
    }
    */
  }

  post {
    always {
      sh 'docker image prune -f || true'
    }
  }
}
