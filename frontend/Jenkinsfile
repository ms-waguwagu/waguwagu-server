pipeline {
  agent any

  environment {
    AWS_REGION = "ap-northeast-2"
    S3_BUCKET  = "waguwagu-s3-bucket-269397878198-ap-northeast-2"
    CF_SECRET_ID  = "T3-Wagu-Secrets"
    CF_SECRET_KEY = "CLOUDFRONT_DISTRIBUTION_ID"
  }

  options {
    disableConcurrentBuilds()
    skipDefaultCheckout(true)
  }

  stages {
    stage('Checkout') {
      steps { checkout scm }
    }

    stage('Change check (frontend only)') {
      steps {
        script {
          def base  = env.GIT_PREVIOUS_SUCCESSFUL_COMMIT ?: env.GIT_PREVIOUS_COMMIT
          def range = base ? "${base}..HEAD" : "HEAD~1..HEAD"
          echo "Diff range: ${range}"

          // frontend 변경만 감지 + frontend/Jenkinsfile만 바뀐 경우는 제외
          def changed = sh(
            script: """
              set -e
              git diff --name-only ${range} \
                | grep -E '^frontend/' \
                | grep -v '^frontend/Jenkinsfile\$' \
                || true
            """,
            returnStdout: true
          ).trim()

          if (!changed) {
            echo "No deployable changes in frontend/ -> SKIP S3/CloudFront"
            env.FRONTEND_CHANGED = "false"
          } else {
            echo "Frontend changes detected -> proceed"
            echo "Changed files:\\n${changed}"
            env.FRONTEND_CHANGED = "true"
          }
        }
      }
    }

    stage('Deploy to S3 (include src/)') {
      when { expression { env.FRONTEND_CHANGED == "true" } }
      steps {
        sh '''
          set -euo pipefail
          DEST="s3://$S3_BUCKET/"

          aws s3 sync "frontend/" "$DEST" --delete --region "$AWS_REGION" \
            --exclude "Jenkinsfile" \
            --exclude ".git/*" \
            --exclude "*.md"

          find frontend -type f -name "*.html" -print0 | while IFS= read -r -d '' f; do
            rel="${f#frontend/}"
            aws s3 cp "$f" "${DEST}${rel}" --region "$AWS_REGION" \
              --cache-control "no-cache, no-store, must-revalidate" \
              --content-type "text/html; charset=utf-8" \
              --metadata-directive REPLACE
          done
        '''
      }
    }

    stage('Invalidate CloudFront (ALL)') {
      when { expression { env.FRONTEND_CHANGED == "true" } }
      steps {
        sh '''
          set -euo pipefail

          SECRET_JSON="$(aws secretsmanager get-secret-value \
            --secret-id "$CF_SECRET_ID" \
            --query "SecretString" \
            --output text \
            --region "$AWS_REGION")"

          CF_ID="$(echo "$SECRET_JSON" | jq -r --arg k "$CF_SECRET_KEY" '.[$k]')"

          if [ -z "$CF_ID" ] || [ "$CF_ID" = "null" ]; then
            echo "[ERROR] CloudFront Distribution ID not found. secret=$CF_SECRET_ID key=$CF_SECRET_KEY"
            exit 1
          fi

          echo "[INFO] Invalidate CloudFront: $CF_ID"
          aws cloudfront create-invalidation \
            --distribution-id "$CF_ID" \
            --paths "/*"
        '''
      }
    }
  }
}
