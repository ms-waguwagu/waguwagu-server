export const TILE_SIZE = 28;

// ë§µ ë””ìžì¸ (ë¬¸ìžì—´ë¡œ ì‹œê°í™”)
// # : ë²½ (Wall) -> 1
// . : ê¸¸ (Path) -> 0
// S : í”Œë ˆì´ì–´ ìŠ¤í° ìœ„ì¹˜ (Spawn) -> 0 (ê¸¸ë¡œ ì²˜ë¦¬ë¨)
// G : ìœ ë ¹/ì  ìŠ¤í° ìœ„ì¹˜ (Ghost) -> 0 (ê¸¸ë¡œ ì²˜ë¦¬ë¨)
// - : ìœ ë ¹ ì§‘ ìž…êµ¬ (Gate) -> 0 (ì¼ë‹¨ ê¸¸ë¡œ ì²˜ë¦¬, ë‚˜ì¤‘ì— í†µê³¼ ë¶ˆê°€ ë¡œì§ ì¶”ê°€ ê°€ëŠ¥)

const MAP_DESIGN = [
  "###############################", // 0
  "#.............................#", // 1
  "#.###.#####.###.###.#####.###.#", // 2
  "#.###.#...#.#.....#.#...#.###.#", // 3
  "#.###.###.#.#######.#.###.###.#", // 4
  "#.............................#", // 5
  "#.#####.#.###########.#.#####.#", // 6
  "#.#.....#.....###.....#.....#.#", // 7
  "#.#.###.#.###.###.###.#.###.#.#", // 8
  "#.#.#.#.#...#.....#...#.#.#.#.#", // 9
  "#.#.#.#.###.#######.###.#.#.#.#", // 10
  "#.#.#.....................#.#.#", // 11
  "#.#.#.###.###GGGGG###.###.#.#.#", // 12
  "#.#.#.#.#.#GGG.G.GGG#.#.#.#.#.#", // 13
  "#...#.#.#.#GGG.G.GGG#.#.#.#...#", // 14
  "###.#.#.#.#GGG.G.GGG#.#.#.#.###", // 15
  "#...#.#.#.#GGG.G.GGG#.#.#.#...#", // 16
  "#.#.#.#.#.#GGG.G.GGG#.#.#.#.#.#", // 17
  "#.#.#.###.###GGGGG###.###.#.#.#", // 18
  "#.#.#.....................#.#.#", // 19
  "#.#.#.###.###########.###.#.#.#", // 20
  "#.#.#.#.#...#.....#...#.#.#.#.#", // 21
  "#.#.###.#.###.#.#.###.#.###.#.#", // 22
  "#.#.....#.....#.#.....#.....#.#", // 23
  "#.#####.#.###########.#.#####.#", // 24
  "#.............................#", // 25
  "#.###.###.#.#######.#.###.###.#", // 26
  "#.#.#.#...#.#.....#.#...#.#.#.#", // 27
  "#.###.#####.###.###.#####.###.#", // 28
  "###############################", // 29
];

// ë¬¸ìžì—´ ë§µì„ 0/1ë¡œ ë³€í™˜
const parseMap = (design) => {
  const mapData = [];
  const spawnPoints = [];

  for (let row = 0; row < design.length; row++) {
    const currentRow = [];
    const rowString = design[row];

    for (let col = 0; col < rowString.length; col++) {
      const char = rowString[col];

      if (char === "#") {
        currentRow.push(1); // ë²½
      } else {
        currentRow.push(0); // ê¸¸

        // í”Œë ˆì´ì–´ ìŠ¤í°ë§Œ ì €ìž¥
        if (char === "S") {
          spawnPoints.push({ x: col, y: row });
        }
      }
    }

    mapData.push(currentRow);
  }

  return { mapData, spawnPoints };
};

// íŒŒì‹± ì‹¤í–‰
const parsed = parseMap(MAP_DESIGN);

export const MAP_DATA = parsed.mapData;
export const SPAWN_POINTS = parsed.spawnPoints;

export const MAP_ROWS = MAP_DATA.length;
export const MAP_COLS = MAP_DATA[0].length;

// ============================
//  ðŸ”¥ ì—¬ê¸° ì¶”ê°€í•˜ë©´ ì •ë‹µ
// ============================

// DOT ìƒì„± í•¨ìˆ˜
export function generateDots(map) {
  const dots = [];

  for (let y = 0; y < map.length; y++) {
    for (let x = 0; x < map[y].length; x++) {
      if (map[y][x] === 0) { // ê¸¸ ìœ„ì—ë§Œ dot ìƒì„±
        dots.push({ x, y, eaten: false });
      }
    }
  }

  return dots;
}